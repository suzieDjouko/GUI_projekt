            # Section des types de cabines
        cabin_selection_layout = QHBoxLayout()
        self.cabin_combo = QComboBox()
        self.cabin_combo.addItem("Sélectionnez un type de cabine")
        self.load_cabin_types()
        self.cabin_combo.currentTextChanged.connect(self.display_selected_cabin_image)

        self.cabin_image_label = QLabel()
        self.cabin_image_label.setAlignment(Qt.AlignCenter)
        self.cabin_image_label.setFixedSize(300, 200)
        self.cabin_image_label.setStyleSheet("border: 1px solid black;")

        cabin_selection_layout.addWidget(QLabel("Type de cabine"))
        cabin_selection_layout.addWidget(self.cabin_combo)
        cabin_selection_layout.addWidget(self.cabin_image_label)
        layout.addLayout(cabin_selection_layout)




    def load_cabin_types(self):
        """Charger les types de cabines dans la barre déroulante."""
        if not os.path.exists(self.cabintype_folder):
            self.cabin_combo.addItem("Aucune cabine disponible")
            return

        for filename in os.listdir(self.cabintype_folder):
            if filename.lower().endswith((".png", ".jpg", ".jpeg")):
                cabin_name = filename.split(".")[0]  # Nom sans extension
                self.cabin_combo.addItem(cabin_name)

    def display_selected_cabin_image(self, cabin_name):
        """Afficher l'image de la cabine sélectionnée."""
        if cabin_name == "Sélectionnez un type de cabine" or cabin_name == "Aucune cabine disponible":
            QMessageBox.warning(self, "Attention", "Aucun type de cabine sélectionné.")
            return

        image_path = os.path.join(self.cabintype_folder, f"{cabin_name}.jpg")
        if not os.path.exists(image_path):  # Si .jpg n'existe pas, chercher d'autres extensions
            for ext in [".png", ".jpeg"]:
                image_path = os.path.join(self.cabintype_folder, f"{cabin_name}{ext}")
                if os.path.exists(image_path):
                    break
            else:
                QMessageBox.warning(self, "Erreur", f"Aucune image trouvée pour la cabine : {cabin_name}.")
                return

        pixmap = QPixmap(image_path).scaled(300, 200, Qt.KeepAspectRatio)
        self.cabin_image_label.setPixmap(pixmap)



         def update_table(self, df):
        """Mettre à jour le tableau avec les résultats filtrés."""
        self.table.setRowCount(len(df))
        self.table.setColumnCount(len(df.columns))
        self.table.setHorizontalHeaderLabels(df.columns)

        for i, row in df.iterrows():
            for j, value in enumerate(row):
                self.table.setItem(i, j, QTableWidgetItem(str(value)))


            def on_night_spin_changed(self):
        """
        Met à jour le DataFrame filtré lorsque la valeur du QSpinBox change.
        """
        selected_night = self.nights_spin.value()
        selected_sea = self.sea_combo.currentText()
        dataframe_filtre_par_mer = self.filter_by_sea(selected_sea, self.df)
        dataframe_filre_par_nuit = self.filter_by_night(selected_night, dataframe_filtre_par_mer)
        print(dataframe_filre_par_nuit)
        self.city_selection_widget = self.create_city_selection()

         def on_sea_combo_changed(self):
        selected_sea = self.sea_combo.currentText()
        filtered_df = self.filter_by_sea(selected_sea, self.df)
        # Vous pouvez utiliser filtered_df pour mettre à jour l'affichage
        print(filtered_df)  # Debug ou mettre à jour un tableau PyQt





        def display_result_table(self, filtered_data):
        """Affiche les voyages filtrés dans la table des résultats."""
        # Réinitialiser la table
        self.reset_table()

        # Obtenir le solde de l'utilisateur
        user_balance = get_user_balance(self.header_user_name_edit.text())

        if filtered_data.empty:
            self.result_label.setText("Aucun résultat trouvé.")
            return

        # Configurer la table
        self.result_table.setRowCount(len(filtered_data))
        self.result_table.setColumnCount(len(filtered_data.columns) + 1)
        self.result_table.setHorizontalHeaderLabels(list(filtered_data.columns) + ["Choose"])

        # Remplir la table
        for i, row_data in filtered_data.iterrows():
            abordable = False  # Vérifie si au moins une cabine est abordable

            # Ajouter les données dans les colonnes
            for j, (col_name, value) in enumerate(row_data.items()):
                if isinstance(value, int) and col_name in [
                    "Innenkabine", "Aussenkabine", "Balkonkabine", "Luxuskabine1", "Luxuskabine2", "Luxuskabine3"
                ]:
                    # Gestion des prix de cabines
                    if value == 0:
                        item = QTableWidgetItem("nicht vorhanden")
                        item.setFlags(Qt.ItemIsEnabled)  # Désactiver l'édition
                        item.setForeground(QColor("gray"))
                    else:
                        item = QTableWidgetItem(f"{value} €")
                        if value <= user_balance:
                            item.setForeground(QColor("green"))  # Prix abordable
                            abordable = True
                        else:
                            item.setForeground(QColor("red"))  # Prix non abordable
                else:
                    # Autres colonnes normales
                    item = QTableWidgetItem(str(value))

                self.result_table.setItem(i, j, item)


            # Ajouter un bouton "Choisir"
            button = QPushButton("Choose")

           # button.clicked.disconnect()  # Déconnecter les anciens signaux, s'ils existent

            if abordable:
                button.setEnabled(True)
                button.setStyleSheet(
                    "background-color: #007bff; color: white; border-radius: 5px; padding: 8px; margin: 4px")
            else:
                button.setEnabled(False)
                button.setStyleSheet(
                    "background-color: lightgray; color: gray; border-radius: 5px; padding: 8px; margin: 4px")
                button.setToolTip("Kontostand nicht ausreichend")

            # Connecter l'événement pour sélectionner le voyage
            button.clicked.connect(lambda _, r=row_data.copy(): self.on_choose_button_clicked(r))

            self.result_table.setCellWidget(i, len(filtered_data.columns), button)

        self.result_table.resizeColumnsToContents()





         def reset_result_page(self):
        """Réinitialiser la page des résultats."""
        self.reset_table()
        filtered_data = self.get_filtered_results()
        self.display_result_table(filtered_data)

    def reset_table(self):
        self.result_table.setRowCount(0)
        self.result_table.setColumnCount(0)
        #self.result_table.setHorizontalHeaderLabels([])

