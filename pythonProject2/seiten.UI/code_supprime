            # Section des types de cabines
        cabin_selection_layout = QHBoxLayout()
        self.cabin_combo = QComboBox()
        self.cabin_combo.addItem("Sélectionnez un type de cabine")
        self.load_cabin_types()
        self.cabin_combo.currentTextChanged.connect(self.display_selected_cabin_image)

        self.cabin_image_label = QLabel()
        self.cabin_image_label.setAlignment(Qt.AlignCenter)
        self.cabin_image_label.setFixedSize(300, 200)
        self.cabin_image_label.setStyleSheet("border: 1px solid black;")

        cabin_selection_layout.addWidget(QLabel("Type de cabine"))
        cabin_selection_layout.addWidget(self.cabin_combo)
        cabin_selection_layout.addWidget(self.cabin_image_label)
        layout.addLayout(cabin_selection_layout)




    def load_cabin_types(self):
        """Charger les types de cabines dans la barre déroulante."""
        if not os.path.exists(self.cabintype_folder):
            self.cabin_combo.addItem("Aucune cabine disponible")
            return

        for filename in os.listdir(self.cabintype_folder):
            if filename.lower().endswith((".png", ".jpg", ".jpeg")):
                cabin_name = filename.split(".")[0]  # Nom sans extension
                self.cabin_combo.addItem(cabin_name)

    def display_selected_cabin_image(self, cabin_name):
        """Afficher l'image de la cabine sélectionnée."""
        if cabin_name == "Sélectionnez un type de cabine" or cabin_name == "Aucune cabine disponible":
            QMessageBox.warning(self, "Attention", "Aucun type de cabine sélectionné.")
            return

        image_path = os.path.join(self.cabintype_folder, f"{cabin_name}.jpg")
        if not os.path.exists(image_path):  # Si .jpg n'existe pas, chercher d'autres extensions
            for ext in [".png", ".jpeg"]:
                image_path = os.path.join(self.cabintype_folder, f"{cabin_name}{ext}")
                if os.path.exists(image_path):
                    break
            else:
                QMessageBox.warning(self, "Erreur", f"Aucune image trouvée pour la cabine : {cabin_name}.")
                return

        pixmap = QPixmap(image_path).scaled(300, 200, Qt.KeepAspectRatio)
        self.cabin_image_label.setPixmap(pixmap)



         def update_table(self, df):
        """Mettre à jour le tableau avec les résultats filtrés."""
        self.table.setRowCount(len(df))
        self.table.setColumnCount(len(df.columns))
        self.table.setHorizontalHeaderLabels(df.columns)

        for i, row in df.iterrows():
            for j, value in enumerate(row):
                self.table.setItem(i, j, QTableWidgetItem(str(value)))


            def on_night_spin_changed(self):
        """
        Met à jour le DataFrame filtré lorsque la valeur du QSpinBox change.
        """
        selected_night = self.nights_spin.value()
        selected_sea = self.sea_combo.currentText()
        dataframe_filtre_par_mer = self.filter_by_sea(selected_sea, self.df)
        dataframe_filre_par_nuit = self.filter_by_night(selected_night, dataframe_filtre_par_mer)
        print(dataframe_filre_par_nuit)
        self.city_selection_widget = self.create_city_selection()

         def on_sea_combo_changed(self):
        selected_sea = self.sea_combo.currentText()
        filtered_df = self.filter_by_sea(selected_sea, self.df)
        # Vous pouvez utiliser filtered_df pour mettre à jour l'affichage
        print(filtered_df)  # Debug ou mettre à jour un tableau PyQt





        def display_result_table(self, filtered_data):
        """Affiche les voyages filtrés dans la table des résultats."""
        # Réinitialiser la table
        self.reset_table()

        # Obtenir le solde de l'utilisateur
        user_balance = get_user_balance(self.header_user_name_edit.text())

        if filtered_data.empty:
            self.result_label.setText("Aucun résultat trouvé.")
            return

        # Configurer la table
        self.result_table.setRowCount(len(filtered_data))
        self.result_table.setColumnCount(len(filtered_data.columns) + 1)
        self.result_table.setHorizontalHeaderLabels(list(filtered_data.columns) + ["Choose"])

        # Remplir la table
        for i, row_data in filtered_data.iterrows():
            abordable = False  # Vérifie si au moins une cabine est abordable

            # Ajouter les données dans les colonnes
            for j, (col_name, value) in enumerate(row_data.items()):
                if isinstance(value, int) and col_name in [
                    "Innenkabine", "Aussenkabine", "Balkonkabine", "Luxuskabine1", "Luxuskabine2", "Luxuskabine3"
                ]:
                    # Gestion des prix de cabines
                    if value == 0:
                        item = QTableWidgetItem("nicht vorhanden")
                        item.setFlags(Qt.ItemIsEnabled)  # Désactiver l'édition
                        item.setForeground(QColor("gray"))
                    else:
                        item = QTableWidgetItem(f"{value} €")
                        if value <= user_balance:
                            item.setForeground(QColor("green"))  # Prix abordable
                            abordable = True
                        else:
                            item.setForeground(QColor("red"))  # Prix non abordable
                else:
                    # Autres colonnes normales
                    item = QTableWidgetItem(str(value))

                self.result_table.setItem(i, j, item)


            # Ajouter un bouton "Choisir"
            button = QPushButton("Choose")

           # button.clicked.disconnect()  # Déconnecter les anciens signaux, s'ils existent

            if abordable:
                button.setEnabled(True)
                button.setStyleSheet(
                    "background-color: #007bff; color: white; border-radius: 5px; padding: 8px; margin: 4px")
            else:
                button.setEnabled(False)
                button.setStyleSheet(
                    "background-color: lightgray; color: gray; border-radius: 5px; padding: 8px; margin: 4px")
                button.setToolTip("Kontostand nicht ausreichend")

            # Connecter l'événement pour sélectionner le voyage
            button.clicked.connect(lambda _, r=row_data.copy(): self.on_choose_button_clicked(r))

            self.result_table.setCellWidget(i, len(filtered_data.columns), button)

        self.result_table.resizeColumnsToContents()





         def reset_result_page(self):
        """Réinitialiser la page des résultats."""
        self.reset_table()
        filtered_data = self.get_filtered_results()
        self.display_result_table(filtered_data)

    def reset_table(self):
        self.result_table.setRowCount(0)
        self.result_table.setColumnCount(0)
        #self.result_table.setHorizontalHeaderLabels([])





    def get_filtered_results(self):

        # Obtenir les valeurs des filtres
        selected_night = self.nights_spin.value()
        selected_sea = self.sea_combo.currentText()
        selected_ship = self.ship_combo.currentText()
        df_filtered = self.df.copy()

        # Filtrer par mer
        if selected_sea != "All":
            df_filtered = self.filter_by_sea(selected_sea, df_filtered)
        # Filtrer par nuit si défini
        if selected_night != 0:
            df_filtered = self.filter_by_night(selected_night, df_filtered)
        #si au moins une ville dans la colone 'Besuchte Stadte
        if selected_ship and selected_ship != "Choose a Ship":
            df_filtered = self.filter_by_ship(selected_ship, df_filtered)

        if self.selected_cities:
            def match_cities(cities):
                if not isinstance(cities, str):  # Sécurité contre les valeurs non textuelles
                    return False
                return any(city.strip() in self.selected_cities for city in cities.split(","))

            df_filtered = df_filtered[df_filtered["Besuchte_Städte"].apply(match_cities)]

        print(f"Filtrage par Meerart : {selected_sea}")
        print(f"Filtrage par Übernachtungen : {selected_night}")
        print(f"Villes sélectionnées : {self.selected_cities}")

        return df_filtered







    def load_data(self):
        """Charger les données depuis le fichier Excel, vérifier les colonnes et nettoyer les données."""
        try:
            # Charger les données
            self.df = pd.read_excel(self.data_file)

            # Vérifier la présence des colonnes nécessaires
            expected_columns = [
                "Meerart","Übernachtungen", "Besuchte_Städte", "Schiffstyp",
                "Innenkabine", "Aussenkabine", "Balkonkabine",
                "Luxuskabine1", "Luxuskabine2", "Luxuskabine3"
            ]
            missing_columns = [col for col in expected_columns if col not in self.df.columns]
            if missing_columns:
                self.show_error(f"Colonnes manquantes : {', '.join(missing_columns)}")
                return

            # Supprimer les lignes entièrement vides
            self.df = self.df.dropna(how='all')

            # Remplacer "nicht vorhanden" par NaN dans les colonnes de cabines
            cabine_columns = [
                "Innenkabine", "Aussenkabine", "Balkonkabine",
                "Luxuskabine1", "Luxuskabine2", "Luxuskabine3"
            ]
            for col in cabine_columns:
                if col in self.df.columns:
                    self.df[col] = self.df[col].replace("nicht vorhanden", 0)

                    # Conversion des colonnes en types appropriés
            type_mappings = {
                "Übernachtungen": int,
                "Meerart": str,
                "Besuchte_Städte": str,
                "Schiffstyp": str,
                "Innenkabine": int,
                "Aussenkabine": int,
                "Balkonkabine": int,
                "Luxuskabine1": int,
                "Luxuskabine2": int,
                "Luxuskabine3": int,
            }
            for col, dtype in type_mappings.items():
                if col in self.df.columns:
                    # Convertir les colonnes numériques en entier
                    if dtype == int:
                        self.df[col] = pd.to_numeric(self.df[col], errors='coerce').fillna(0).astype(int)
                    else:
                        self.df[col] = self.df[col].astype(dtype)

        except FileNotFoundError:
            self.show_error(f"Fichier introuvable : {self.data_file}")
        except Exception as e:
            self.show_error(f"Impossible de charger les données : {e}")






                def create_reisezeit_page(self, row_data):
        layout = QVBoxLayout()

        # Détails du voyage
        trip_details = (
            f"<b>Trip number:</b> {row_data['Reisenummer']}<br>"
            f"<b>Sea:</b> {row_data['Meerart']}<br>"
            f"<b>Number of nights:</b> {row_data['Übernachtungen']}<br>"
            f"<b>Cities:</b> {row_data['Besuchte_Städte']}<br>"
            f"<b>Ship type:</b> {row_data['Schiffstyp']}"
        )

        self.trip_details_label = QLabel()
        self.trip_details_label.setText(trip_details)
        self.trip_details_label.setStyleSheet("font-size: 20px; margin-bottom: 20px;")
        layout.addWidget(self.trip_details_label)

        # Section des villes avec boutons de défilement
        layout.addWidget(QLabel("Cities:"))
        self.city_scroll_area = QScrollArea()
        city_widget = self.create_city_selection2(row_data)  # Crée les images des villes sans boutons
        self.city_scroll_area.setWidget(city_widget)
        self.city_scroll_area.setWidgetResizable(True)
        layout.addWidget(self.city_scroll_area)

        # Boutons de défilement pour les villes
        scroll_buttons_layout = QHBoxLayout()
        self.left_scroll_button = QPushButton("<")
        self.right_scroll_button = QPushButton(">")
        self.left_scroll_button.clicked.connect(self.scroll_cities_left)
        self.right_scroll_button.clicked.connect(self.scroll_cities_right)
        scroll_buttons_layout.addWidget(self.left_scroll_button)
        scroll_buttons_layout.addWidget(self.right_scroll_button)
        layout.addLayout(scroll_buttons_layout)

        # Affichage des types de navires
        layout.addWidget(QLabel("Ship Types:"))
        self.ship_image_label = QLabel()
        self.ship_image_label.setFixedSize(300, 250)  # Taille fixe pour l'image
        self.ship_image_label.setAlignment(Qt.AlignCenter)
        self.display_selected_ship_image(row_data['Schiffstyp'])  # Afficher l'image du navire
        layout.addWidget(self.ship_image_label)

        # Affichage des cabines
        layout.addWidget(QLabel("Cabin:"))
        self.cabin_image_label = QLabel()
        self.cabin_image_label.setFixedSize(300, 250)  # Taille fixe pour l'image
        self.cabin_image_label.setAlignment(Qt.AlignCenter)
        layout.addWidget(self.cabin_image_label)

        self.update_cabine_choose()

        # Sélection des dates
        layout.addWidget(QLabel("Departure Date:"))
        self.departure_date_edit = QDateEdit()
        self.departure_date_edit.setCalendarPopup(True)
        self.departure_date_edit.setMinimumDate(QDate(2025, 5, 1))
        self.departure_date_edit.setMaximumDate(QDate(2025, 10, 31))
        self.departure_date_edit.dateChanged.connect(self.on_departure_date_changed)
        layout.addWidget(self.departure_date_edit)

        layout.addWidget(QLabel("Return Date:"))
        self.return_date_edit = QDateEdit()
        self.return_date_edit.setCalendarPopup(True)
        self.return_date_edit.setMinimumDate(QDate(2025, 5, 2))
        self.return_date_edit.setMaximumDate(QDate(2025, 10, 31))
        layout.addWidget(self.return_date_edit)

        # Boutons "Return" et "Confirm"
        button_layout = QHBoxLayout()
        back_button = QPushButton("Return")
        back_button.setStyleSheet(back_button_style)
        back_button.clicked.connect(self.on_back_to_cabin_clicked)
        button_layout.addWidget(back_button)

        confirm_button = QPushButton("Confirm")
        confirm_button.setStyleSheet("""
            QPushButton {
                background-color: green;
                color: white;
                font-size: 16px;
                padding: 10px;
                border-radius: 8px;
            }
            QPushButton:hover {
                background-color: darkgreen;
            }
        """)
        confirm_button.clicked.connect(self.on_confirm_date_selection)
        button_layout.addWidget(confirm_button)
        layout.addLayout(button_layout)

        return layout





         def update_payment_page(self, cabin_type, cabin_price):
        """
        Update payment page details with selected cabin and price.
        """
        # Update cabin details label
        try:
            # Mettre à jour les détails de la cabine
            self.cabin_details_label.setText(
                f"<b>Selected Cabin:</b> {cabin_type}<br>"
                f"<b>Price:</b> {self.selected_cabin_price} €"

                #f"<b>Price:</b> {cabin_price} €"
            )

            # Mettre à jour le prix total
            self.total_price_label.setText(f"Total Price: {cabin_price} €")
            print(f"Payment page updated for cabin: {cabin_type}, price: {cabin_price} €")
        except Exception as e:
            print(f"Error in update_payment_page: {e}")



        departure_date = self.departure_date_edit.date().toString("dd-MM-yyyy")
        return_date = self.return_date_edit.date()
        nights = self.selected_trip_data.get('Übernachtungen')
        calculated_return_date = self.departure_date_edit.date().addDays(nights)
        if return_date < calculated_return_date:
            show_return_date_error("Invalid Return Date","The selected return date is incompatible.",f"The return date must account for the number of nights of your trip.\n"
        f"The minimum return date should be: {calculated_return_date.toString('dd-MM-yyyy')}.")

            return_date = calculated_return_date
            self.return_date_edit.setDate(return_date)
        return_date_str = return_date.toString("dd-MM-yyyy")

        self.update_gekauft_container(departure_date, return_date_str)
        self.reisezeit_confirm_button.setEnabled(True)
        self.reisezeit_confirm_button.setStyleSheet(confirmbtnstyle)

        print(f"Dates validées : Departure: {departure_date}, Return: {return_date}")









####REISEZEIT
self.result_layout = QVBoxLayout()
        self.result_label = QLabel("List of Trips:")
        self.result_layout.addWidget(self.result_label)
        self.result_list = QListWidget()
        self.result_list.setStyleSheet(Qlist_style)
        self.result_layout.addWidget(self.result_list)
        self.return_button = QPushButton("Return")
        self.return_button.setStyleSheet(back_button_style)
        self.return_button.clicked.connect(lambda: self.stacked_widget.setCurrentWidget(self.selection_page))
        self.result_layout.addWidget(self.return_button)

        self.result_page.setLayout(self.result_layout)

        #SEITE KABINEN
        #self.cabintype_folder = "../images/Kabinentypen"

        self.cabin_layout = QVBoxLayout()

        self.cabin_summary_label = QLabel()
        self.cabin_summary_label.setAlignment(Qt.AlignTop)
        self.cabin_summary_label.setStyleSheet("font-size: 18px; font-weight: bold; margin-bottom: 10px;")
        #self.cabin_layout.addWidget(self.cabin_summary_label)
        back_button = QPushButton("Return")
        back_button.setStyleSheet(back_button_style)
        back_button.clicked.connect(self.on_back_to_results_clicked)  # Connecter au retour

        self.cabin_scroll_area = QScrollArea()
        self.cabin_scroll_area.setWidgetResizable(True)


        cabin_content_widget = QWidget()
        cabin_content_widget.setLayout(self.cabin_layout)

        self.cabin_scroll_area.setWidget(cabin_content_widget)

        cabin_page_layout = QVBoxLayout()
        cabin_page_layout.addWidget(self.cabin_summary_label)
        cabin_page_layout.addWidget(self.cabin_scroll_area)
        cabin_page_layout.addWidget(back_button)
        self.cabin_page.setLayout(cabin_page_layout)

        # SEITE DATUMSAUSWAHL
        self.reisezeit_page_layout = QVBoxLayout()  # Hauptlayout für die Seite

        # Titel außerhalb des Scrollens hinzufügen
        adjust_title = QLabel("<h2>Adjust Your Travel Time</h2>")
        adjust_title.setAlignment(Qt.AlignCenter)
        self.reisezeit_page_layout.addWidget(adjust_title)

        # Abschnitt mit scrollbarem Inhalt
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)

        # Container für scrollbare Inhalte
        scrollable_widget = QWidget()
        self.reisezeit_layout = QVBoxLayout(scrollable_widget)

        # Reisedetails hinzufügen
        self.reisezeit_trip_details_label = QLabel()
        self.reisezeit_trip_details_label.setStyleSheet("font-size: 18px; margin-bottom: 20px;")
        self.reisezeit_layout.addWidget(self.reisezeit_trip_details_label)

        # Abschnitt für Städte
        self.reisezeit_layout.addWidget(QLabel("Cities:"))
        self.reisezeit_city_scroll_area = QScrollArea()
        self.reisezeit_city_scroll_area.setWidgetResizable(True)
        self.reisezeit_layout.addWidget(self.reisezeit_city_scroll_area)

        # Bilder von Bootstypen und Kabinen
        self.reisezeit_ship_cabin_layout = QHBoxLayout()
        ship_layout = QVBoxLayout()
        ship_layout.addWidget(QLabel("Ship Type:"))
        self.reisezeit_ship_image_label = QLabel()
        self.reisezeit_ship_image_label.setFixedSize(300, 250)
        self.reisezeit_ship_image_label.setAlignment(Qt.AlignCenter)
        ship_layout.addWidget(self.reisezeit_ship_image_label)
        self.reisezeit_ship_cabin_layout.addLayout(ship_layout)

        cabin_layout = QVBoxLayout()
        cabin_layout.addWidget(QLabel("Cabin:"))
        self.reisezeit_cabin_image_label = QLabel()
        self.reisezeit_cabin_image_label.setFixedSize(300, 250)
        self.reisezeit_cabin_image_label.setAlignment(Qt.AlignCenter)
        cabin_layout.addWidget(self.reisezeit_cabin_image_label)
        self.reisezeit_ship_cabin_layout.addLayout(cabin_layout)

        self.reisezeit_layout.addLayout(self.reisezeit_ship_cabin_layout)

        # Datumsauswahlen hinzufügen
        self.reisezeit_layout.addWidget(QLabel("Departure Date:"))
        self.departure_date_edit = QDateEdit()
        self.departure_date_edit.setStyleSheet(Datestyle)
        self.departure_date_edit.setCalendarPopup(True)
        self.departure_date_edit.setMinimumDate(QDate(2025, 5, 1))
        self.departure_date_edit.setMaximumDate(QDate(2025, 10, 31))
        self.reisezeit_layout.addWidget(self.departure_date_edit)

        self.reisezeit_layout.addWidget(QLabel("Return Date:"))
        self.return_date_edit = QDateEdit()
        self.return_date_edit.setStyleSheet(Datestyle)
        self.return_date_edit.setCalendarPopup(True)
        self.return_date_edit.setMinimumDate(QDate(2025, 5, 2))
        self.return_date_edit.setMaximumDate(QDate(2025, 10, 31))
        self.reisezeit_layout.addWidget(self.return_date_edit)
        date_button_layout = QHBoxLayout()
        date_button_layout.addStretch()

        self.validate_date_button = QPushButton("Valid")
        self.validate_date_button.setFixedSize(150, 40)
        self.validate_date_button.setStyleSheet(validbtnstyle)
        self.validate_date_button.clicked.connect(self.on_validate_date_clicked)
        date_button_layout.addWidget(self.validate_date_button,alignment=Qt.AlignRight)

        self.cancel_date_button = QPushButton("Cancel")
        self.cancel_date_button.setFixedSize(150, 40)
        self.cancel_date_button.setStyleSheet(cancelstyle)
        self.cancel_date_button.clicked.connect(self.on_cancel_date_clicked)
        date_button_layout.addWidget(self.cancel_date_button,alignment=Qt.AlignRight)

        # Das Layout der Schaltflächen zum Hauptlayout hinzufügen
        self.reisezeit_layout.addLayout(date_button_layout)

        # Abschnitt für gekaufte Reisen

        self.reisezeit_layout.addWidget(QLabel("<b>Purchased Products</b>"))
        self.gekauft_scroll_area = QScrollArea()
        self.gekauft_scroll_area.setWidgetResizable(True)

        self.date_layout = QVBoxLayout()


        self.gekauft_container = QWidget()

        self.gekauft_layout = QVBoxLayout(self.gekauft_container)
        #self.gekauft_layout.addLayout(self.date_layout)
        self.gekauft_layout.setContentsMargins(20, 10, 20, 10)
        self.gekauft_layout.setSpacing(15)



        self.gekauft_scroll_area.setWidget(self.gekauft_container)
        self.reisezeit_layout.addWidget(self.gekauft_scroll_area)

        scroll_area.setWidget(scrollable_widget)
        self.reisezeit_page_layout.addWidget(scroll_area)

        button_layout = QHBoxLayout()
        self.reisezeit_return_button = QPushButton("Return")
        self.reisezeit_return_button.setStyleSheet(back_button_style)
        self.reisezeit_return_button.clicked.connect(self.on_back_to_cabin_clicked)

        self.reisezeit_confirm_button = QPushButton("Confirm")
        self.reisezeit_confirm_button.setEnabled(False)
        self.reisezeit_confirm_button.setStyleSheet(confirmbtnstyledisable)

        self.reisezeit_confirm_button.clicked.connect(self.on_confirm_date_selection)

        button_layout.addWidget(self.reisezeit_return_button)
        button_layout.addWidget(self.reisezeit_confirm_button)

        self.reisezeit_page_layout.addLayout(button_layout)

        # Seite Reisezeit einrichten
        self.reisezeit_page.setLayout(self.reisezeit_page_layout)
#####